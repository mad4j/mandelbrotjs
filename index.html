<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Mandelbrot Explorer</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #000;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 11px;
            font-weight: 300;
            letter-spacing: 0.5px;
            pointer-events: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 4px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: opacity 0.3s ease;
        }

        .info.hidden {
            opacity: 0;
        }

        .reset-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .reset-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.2);
        }

        .gesture-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.4);
            font-size: 14px;
            text-align: center;
            pointer-events: none;
            animation: fadeOut 3s ease-out forwards;
            animation-delay: 1s;
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="info" id="info">
        <div>ZOOM: <span id="zoom">1.0×</span></div>
        <div>ITER: <span id="iterations">128</span></div>
    </div>
    
    <div class="gesture-hint">
        Pinch to zoom • Drag to pan • Double tap to zoom
    </div>

    <div class="reset-btn" id="resetBtn">↺</div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', {
            antialias: false,
            preserveDrawingBuffer: false,
            powerPreference: 'high-performance'
        });

        if (!gl) {
            alert('WebGL2 not supported');
        }

        // Vertex shader with improved precision
        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_coord;
            out vec2 v_coord_low;
            uniform vec2 u_center;
            uniform vec2 u_center_low;
            uniform float u_zoom;
            uniform float u_aspectRatio;
            
            // Double precision addition using Dekker's algorithm
            vec2 ds_add(vec2 a_hi, vec2 a_lo, vec2 b_hi, vec2 b_lo) {
                vec2 s = a_hi + b_hi;
                vec2 v = s - a_hi;
                vec2 e = (a_hi - (s - v)) + (b_hi - v) + a_lo + b_lo;
                return vec2(s.x + e.x, s.y + e.y);
            }
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                vec2 coord = a_position;
                coord.x *= u_aspectRatio;
                
                // Scale coordinate by zoom with higher precision
                vec2 scaled = coord / u_zoom;
                
                // Add center with double precision
                vec2 result = ds_add(scaled, vec2(0.0), u_center, u_center_low);
                v_coord = result;
                v_coord_low = vec2(0.0); // For future use in double precision arithmetic
            }
        `;

        // Fragment shader with improved precision
        const fragmentShaderSource = `#version 300 es
            precision highp float;
            in vec2 v_coord;
            in vec2 v_coord_low;
            out vec4 fragColor;
            uniform int u_maxIterations;
            
            // Double precision arithmetic functions
            vec2 ds_add(vec2 a, vec2 b) {
                vec2 s = a + b;
                vec2 v = s - a;
                vec2 e = (a - (s - v)) + (b - v);
                return vec2(s.x + e.x, s.y + e.y);
            }
            
            vec2 ds_mult(vec2 a, vec2 b) {
                vec2 p = a * b;
                vec2 s = a * b;
                return p;
            }
            
            vec3 palette(float t) {
                // Enhanced color palette for better visualization at high zoom
                t = clamp(t, 0.0, 1.0);
                if (t < 0.5) {
                    return mix(vec3(0.0, 0.0, 0.4), vec3(0.4, 0.0, 0.8), t * 2.0);
                } else {
                    return mix(vec3(0.4, 0.0, 0.8), vec3(1.0, 1.0, 1.0), (t - 0.5) * 2.0);
                }
            }
            
            void main() {
                vec2 c = v_coord;
                vec2 z = vec2(0.0);
                int iter = 0;
                
                // Enhanced iteration loop with better escape condition
                for(int i = 0; i < 2048; i++) {
                    if(i >= u_maxIterations) break;
                    
                    // z = z^2 + c with higher precision
                    float x = z.x * z.x - z.y * z.y + c.x;
                    float y = 2.0 * z.x * z.y + c.y;
                    z = vec2(x, y);
                    
                    float magnitude_sq = dot(z, z);
                    if(magnitude_sq > 256.0) { // Increased escape radius for better precision
                        iter = i;
                        break;
                    }
                }
                
                if(iter == 0 || iter == u_maxIterations) {
                    // Inside the set - black
                    fragColor = vec4(0.0, 0.0, 0.0, 1.0);
                } else {
                    // Outside the set - enhanced smooth coloring
                    float magnitude_sq = dot(z, z);
                    float smooth_iter = float(iter) - log2(log2(magnitude_sq)) + 4.0;
                    vec3 color = palette(smooth_iter / float(u_maxIterations));
                    fragColor = vec4(color, 1.0);
                }
            }
        `;

        // Compile shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        // Create program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        // Get uniform locations
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const centerLocation = gl.getUniformLocation(program, 'u_center');
        const centerLowLocation = gl.getUniformLocation(program, 'u_center_low');
        const zoomLocation = gl.getUniformLocation(program, 'u_zoom');
        const aspectRatioLocation = gl.getUniformLocation(program, 'u_aspectRatio');
        const maxIterationsLocation = gl.getUniformLocation(program, 'u_maxIterations');

        // Create vertex buffer
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);

        // Create VAO
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.enableVertexAttribArray(positionLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // State with improved precision
        let center = [-0.5, 0.0];
        let centerLow = [0.0, 0.0]; // Low precision part for double precision arithmetic
        let zoom = 0.75; // Increased to 0.75 for closer initial view
        let maxIterations = 128;

        // Helper functions for double precision arithmetic
        function splitDouble(x) {
            const factor = 134217729.0; // 2^27 + 1
            const c = factor * x;
            const hi = c - (c - x);
            const lo = x - hi;
            return [hi, lo];
        }

        function addDouble(a_hi, a_lo, b_hi, b_lo) {
            const s = a_hi + b_hi;
            const v = s - a_hi;
            const e = (a_hi - (s - v)) + (b_hi - v) + a_lo + b_lo;
            return [s, e];
        }

        // Gesture state
        let isDragging = false;
        let lastTouch = null;
        let touches = [];
        let lastTap = 0;
        let initialDistance = 0;
        let initialZoom = 1;

        function resize() {
            const dpr = window.devicePixelRatio;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function render() {
            gl.useProgram(program);
            gl.bindVertexArray(vao);
            
            gl.uniform2f(centerLocation, center[0], center[1]);
            gl.uniform2f(centerLowLocation, centerLow[0], centerLow[1]);
            gl.uniform1f(zoomLocation, zoom);
            gl.uniform1f(aspectRatioLocation, canvas.width / canvas.height);
            gl.uniform1i(maxIterationsLocation, maxIterations);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            document.getElementById('zoom').textContent = 
                zoom > 1000 ? zoom.toExponential(1) : zoom.toFixed(1) + '×';
            document.getElementById('iterations').textContent = maxIterations;
        }

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (touches.length === 1) {
                isDragging = true;
                lastTouch = { x: touches[0].clientX, y: touches[0].clientY };
                
                // Double tap
                const now = Date.now();
                if (now - lastTap < 300) {
                    const x = (touches[0].clientX / window.innerWidth) * 2 - 1;
                    const y = -((touches[0].clientY / window.innerHeight) * 2 - 1);
                    
                    // Update center with improved precision
                    const dx = x * (canvas.width / canvas.height) / zoom;
                    const dy = y / zoom;
                    
                    const [newCenterX, newCenterLowX] = addDouble(center[0], centerLow[0], dx, 0);
                    const [newCenterY, newCenterLowY] = addDouble(center[1], centerLow[1], dy, 0);
                    
                    center[0] = newCenterX;
                    center[1] = newCenterY;
                    centerLow[0] = newCenterLowX;
                    centerLow[1] = newCenterLowY;
                    
                    zoom *= 2;
                    maxIterations = Math.min(2048, Math.floor(128 + Math.log10(zoom) * 75));
                    render();
                }
                lastTap = now;
            } else if (touches.length === 2) {
                isDragging = false;
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                initialDistance = Math.sqrt(dx * dx + dy * dy);
                initialZoom = zoom;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (isDragging && touches.length === 1 && lastTouch) {
                const dx = touches[0].clientX - lastTouch.x;
                const dy = touches[0].clientY - lastTouch.y;
                
                // Calculate movement with improved precision
                const moveX = -dx / window.innerWidth * 2 / zoom * (canvas.width / canvas.height);
                const moveY = dy / window.innerHeight * 2 / zoom;
                
                const [newCenterX, newCenterLowX] = addDouble(center[0], centerLow[0], moveX, 0);
                const [newCenterY, newCenterLowY] = addDouble(center[1], centerLow[1], moveY, 0);
                
                center[0] = newCenterX;
                center[1] = newCenterY;
                centerLow[0] = newCenterLowX;
                centerLow[1] = newCenterLowY;
                
                lastTouch = { x: touches[0].clientX, y: touches[0].clientY };
                render();
            } else if (touches.length === 2 && initialDistance > 0) {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const scale = distance / initialDistance;
                zoom = Math.max(0.1, Math.min(1e15, initialZoom * scale)); // Increased zoom limit
                maxIterations = Math.min(2048, Math.floor(128 + Math.log10(zoom) * 75)); // Improved scaling
                render();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDragging = false;
            lastTouch = null;
            if (e.touches.length === 0) {
                initialDistance = 0;
            }
        });

        // Mouse events
        let mouseDown = false;
        let mouseStart = null;

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseStart = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown && mouseStart) {
                const dx = e.clientX - mouseStart.x;
                const dy = e.clientY - mouseStart.y;
                
                // Calculate movement with improved precision
                const moveX = -dx / window.innerWidth * 2 / zoom * (canvas.width / canvas.height);
                const moveY = dy / window.innerHeight * 2 / zoom;
                
                const [newCenterX, newCenterLowX] = addDouble(center[0], centerLow[0], moveX, 0);
                const [newCenterY, newCenterLowY] = addDouble(center[1], centerLow[1], moveY, 0);
                
                center[0] = newCenterX;
                center[1] = newCenterY;
                centerLow[0] = newCenterLowX;
                centerLow[1] = newCenterLowY;
                
                mouseStart = { x: e.clientX, y: e.clientY };
                render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
            mouseStart = null;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scale = e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(0.1, Math.min(1e15, zoom * scale)); // Increased zoom limit
            maxIterations = Math.min(2048, Math.floor(128 + Math.log10(zoom) * 75)); // Improved scaling
            render();
        });

        // Reset button
        document.getElementById('resetBtn').addEventListener('click', () => {
            center = [-0.5, 0.0];
            centerLow = [0.0, 0.0];
            zoom = 0.75;
            maxIterations = 128;
            render();
        });

        // Initialize
        window.addEventListener('resize', () => {
            resize();
            render();
        });
        
        resize();
        render();

        // Service Worker for PWA
        if ('serviceWorker' in navigator) {
            const sw = `
                self.addEventListener('install', e => self.skipWaiting());
                self.addEventListener('activate', e => e.waitUntil(clients.claim()));
                self.addEventListener('fetch', e => e.respondWith(fetch(e.request)));
            `;
            const blob = new Blob([sw], { type: 'application/javascript' });
            navigator.serviceWorker.register(URL.createObjectURL(blob));
        }

        // Auto-hide info
        let infoTimeout;
        function showInfo() {
            document.getElementById('info').classList.remove('hidden');
            clearTimeout(infoTimeout);
            infoTimeout = setTimeout(() => {
                document.getElementById('info').classList.add('hidden');
            }, 3000);
        }

        canvas.addEventListener('touchstart', showInfo);
        canvas.addEventListener('mousedown', showInfo);
        showInfo();
    </script>
</body>
</html>