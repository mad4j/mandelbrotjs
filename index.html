
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <title>Mandelbrot Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            background: #000;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', {
            antialias: false,
            preserveDrawingBuffer: false,
            powerPreference: 'high-performance'
        });

        if (!gl) {
            alert('WebGL2 not supported');
        }

        // Check for double precision support
        const hasDoublePrecision = gl.getExtension('EXT_shader_texture_lod') !== null;

        // Vertex shader
        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_coord;
            uniform vec2 u_center;
            uniform float u_zoom;
            uniform float u_aspectRatio;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_coord = u_center + (a_position * vec2(u_aspectRatio, 1.0)) / u_zoom;
            }
        `;

        // Fragment shader with optimized Mandelbrot calculation
        const fragmentShaderSource = `#version 300 es
            precision highp float;
            in vec2 v_coord;
            out vec4 fragColor;
            uniform int u_maxIterations;
            uniform float u_zoom;
            
            // Custom smooth interpolation function
            float smoothstepCustom(float edge0, float edge1, float x) {
                float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
                return t * t * (3.0 - 2.0 * t);
            }
            
            void mandelbrotFloat(vec2 c, out int iter, out float escapeRadius) {
                vec2 z = vec2(0.0);
                iter = 0;
                escapeRadius = 0.0;
                
                // Early bailout for points obviously outside the set
                float c_dot = dot(c, c);
                if(c_dot > 4.0) {
                    iter = 1;
                    escapeRadius = c_dot;
                    return;
                }
                
                for(int i = 0; i < 1024; i++) {
                    if(i >= u_maxIterations) break;
                    
                    float zx2 = z.x * z.x;
                    float zy2 = z.y * z.y;
                    
                    if(zx2 + zy2 > 4.0) {
                        iter = i;
                        escapeRadius = zx2 + zy2;
                        return;
                    }
                    
                    // z = z^2 + c (optimized to avoid duplicate calculations)
                    float zxy = z.x * z.y;
                    z.x = zx2 - zy2 + c.x;
                    z.y = 2.0 * zxy + c.y;
                }
                
                if(iter == u_maxIterations) {
                    escapeRadius = dot(z, z);
                }
            }
            
            vec3 getColor(float t) {
                // Enhanced grayscale palette with smooth gradients
                t = clamp(t, 0.0, 1.0);
                // Smooth curve for better visual contrast
                t = smoothstepCustom(0.0, 1.0, t);
                return vec3(1.0 - t);
            }
            
            ${hasDoublePrecision ? `
            // Double precision version for high zoom levels
            void mandelbrotDouble(dvec2 c, out int iter, out double escapeRadius) {
                dvec2 z = dvec2(0.0);
                iter = 0;
                escapeRadius = 0.0;
                
                // Early bailout for points obviously outside the set
                double c_dot = dot(c, c);
                if(c_dot > 4.0) {
                    iter = 1;
                    escapeRadius = c_dot;
                    return;
                }
                
                for(int i = 0; i < 1024; i++) {
                    if(i >= u_maxIterations) break;
                    
                    double zx2 = z.x * z.x;
                    double zy2 = z.y * z.y;
                    
                    if(zx2 + zy2 > 4.0) {
                        iter = i;
                        escapeRadius = zx2 + zy2;
                        return;
                    }
                    
                    // z = z^2 + c
                    double zxy = z.x * z.y;
                    z.x = zx2 - zy2 + c.x;
                    z.y = 2.0 * zxy + c.y;
                }
                
                if(iter == u_maxIterations) {
                    escapeRadius = dot(z, z);
                }
            }
            ` : ''}
            
            void main() {
                int iter;
                float escapeRadius;
                
                ${hasDoublePrecision ? `
                // Use double precision for high zoom levels (> 1000x)
                if(u_zoom > 1000.0) {
                    dvec2 c = dvec2(v_coord);
                    double escapeRadiusDouble;
                    mandelbrotDouble(c, iter, escapeRadiusDouble);
                    escapeRadius = float(escapeRadiusDouble);
                } else {
                    mandelbrotFloat(v_coord, iter, escapeRadius);
                }
                ` : `
                // Fallback to single precision
                mandelbrotFloat(v_coord, iter, escapeRadius);
                `}
                
                if(iter == 0 || iter == u_maxIterations) {
                    fragColor = vec4(0.0, 0.0, 0.0, 1.0);
                } else {
                    // Smooth coloring with escape radius
                    float smoothIter = float(iter) + 1.0 - log2(log2(escapeRadius));
                    float t = smoothIter / float(u_maxIterations);
                    vec3 color = getColor(t);
                    fragColor = vec4(color, 1.0);
                }
            }
        `;

        // Compile shader
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
        }

        // Get uniform locations
        const centerLocation = gl.getUniformLocation(program, 'u_center');
        const zoomLocation = gl.getUniformLocation(program, 'u_zoom');
        const aspectRatioLocation = gl.getUniformLocation(program, 'u_aspectRatio');
        const maxIterationsLocation = gl.getUniformLocation(program, 'u_maxIterations');

        // Create full-screen quad
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,  1, -1, -1,  1,
            -1,  1,  1, -1,  1,  1
        ]), gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.enableVertexAttribArray(positionLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // State
        let center = [-0.5, 0.0];
        let zoom = 0.75; // Will be calculated based on aspect ratio
        let maxIterations = 128;
        let userHasInteracted = false; // Track if user has panned or zoomed manually

        // Calculate initial zoom to ensure complete Mandelbrot set is visible
        function calculateInitialZoom() {
            const aspectRatio = canvas.width / canvas.height;
            // Mandelbrot set bounds: x ∈ [-2.5, 1.0], y ∈ [-1.25, 1.25]
            // With center at [-0.5, 0.0], we need:
            // - x range: [-2.5, 1.0] requires ±2.0 around -0.5
            // - y range: [-1.25, 1.25] requires ±1.25 around 0
            // From shader: x_range = ±aspectRatio/zoom, y_range = ±1/zoom
            return Math.min(aspectRatio / 2.0, 0.8);
        }

        // Gesture state
        let isDragging = false;
        let lastTouch = null;
        let touches = [];
        let lastTap = 0;
        let initialDistance = 0;
        let initialZoom = 1;

        function resize() {
            const dpr = window.devicePixelRatio;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function render() {
            gl.useProgram(program);
            gl.bindVertexArray(vao);
            
            // Pass uniforms to both vertex and fragment shaders
            gl.uniform2f(centerLocation, center[0], center[1]);
            gl.uniform1f(zoomLocation, zoom);
            gl.uniform1f(aspectRatioLocation, canvas.width / canvas.height);
            
            // Optimized iteration count based on zoom level and double precision support
            const baseIterations = hasDoublePrecision && zoom > 1000 ? 256 : 128;
            const adaptiveIterations = Math.min(1024, Math.max(baseIterations, 
                Math.floor(baseIterations + Math.log10(Math.max(1, zoom)) * 32)));
            maxIterations = adaptiveIterations;
            
            gl.uniform1i(maxIterationsLocation, maxIterations);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            userHasInteracted = true;
            
            const now = Date.now();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                lastTouch = { x: touch.clientX, y: touch.clientY };
                
                // Double tap detection
                if (now - lastTap < 300) {
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    
                    const dx = (touch.clientX - centerX) / window.innerWidth;
                    const dy = (touch.clientY - centerY) / window.innerHeight;
                    
                    center[0] += dx * 2 / zoom * (canvas.width / canvas.height);
                    center[1] -= dy * 2 / zoom;
                    
                    zoom = Math.min(1e10, zoom * 2);
                    render();
                }
                lastTap = now;
            } else if (e.touches.length === 2) {
                isDragging = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                initialDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                initialZoom = zoom;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            userHasInteracted = true;
            
            if (e.touches.length === 1 && lastTouch) {
                const touch = e.touches[0];
                const dx = touch.clientX - lastTouch.x;
                const dy = touch.clientY - lastTouch.y;
                
                center[0] -= dx / window.innerWidth * 2 / zoom * (canvas.width / canvas.height);
                center[1] += dy / window.innerHeight * 2 / zoom;
                
                lastTouch = { x: touch.clientX, y: touch.clientY };
                render();
            } else if (e.touches.length === 2 && initialDistance > 0) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const distance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                const scale = distance / initialDistance;
                zoom = Math.max(0.1, Math.min(1e10, initialZoom * scale));
                render();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDragging = false;
            lastTouch = null;
            if (e.touches.length === 0) {
                initialDistance = 0;
            }
        });

        // Mouse events
        let mouseDown = false;
        let mouseStart = null;

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseStart = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown && mouseStart) {
                userHasInteracted = true;
                const dx = e.clientX - mouseStart.x;
                const dy = e.clientY - mouseStart.y;
                center[0] -= dx / window.innerWidth * 2 / zoom * (canvas.width / canvas.height);
                center[1] += dy / window.innerHeight * 2 / zoom;
                mouseStart = { x: e.clientX, y: e.clientY };
                render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
            mouseStart = null;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            userHasInteracted = true;
            const scale = e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(0.1, Math.min(1e10, zoom * scale));
            render();
        });

        // Initialize
        window.addEventListener('resize', () => {
            resize();
            // Only recalculate zoom for orientation changes if user hasn't manually interacted
            if (!userHasInteracted && center[0] === -0.5 && center[1] === 0.0) {
                zoom = calculateInitialZoom();
            }
            render();
        });
        
        resize();
        zoom = calculateInitialZoom(); // Set initial zoom based on aspect ratio
        render();
    </script>
</body>
</html>
