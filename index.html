<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Mandelbrot Explorer</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #000;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 11px;
            font-weight: 300;
            letter-spacing: 0.5px;
            pointer-events: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 4px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: opacity 0.3s ease;
        }

        .info.hidden {
            opacity: 0;
        }

        .reset-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .reset-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.2);
        }

        .gesture-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.4);
            font-size: 14px;
            text-align: center;
            pointer-events: none;
            animation: fadeOut 3s ease-out forwards;
            animation-delay: 1s;
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="info" id="info">
        <div>ZOOM: <span id="zoom">1.0×</span></div>
        <div>ITER: <span id="iterations">128</span></div>
    </div>
    
    <div class="gesture-hint">
        Pinch to zoom • Drag to pan • Double tap to zoom
    </div>

    <div class="reset-btn" id="resetBtn">↺</div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', {
            alpha: false,
            willReadFrequently: false
        });

        // Web Workers for computation and rendering
        let computeWorker = null;
        let renderWorker = null;
        
        // Image data for rendering
        let imageData = null;
        let mandelData = null;
        let smoothMandelData = null;
        
        // Rendering state
        let isRendering = false;
        
        // Create grayscale color palette (256 colors)
        function createGrayscalePalette() {
            const colors = new Uint32Array(256);
            for (let i = 0; i < 255; i++) {
                // Enhanced grayscale with smooth curve
                let t = i / 255.0;
                // Apply smoothstep for better visual contrast
                t = t * t * (3.0 - 2.0 * t);
                const gray = Math.floor((1.0 - t) * 255);
                // Pack as RGBA in little-endian format (ABGR)
                colors[i] = (255 << 24) | (gray << 16) | (gray << 8) | gray;
            }
            colors[255] = 0; // Black for points in the set
            return colors;
        }
        
        const grayscalePalette = createGrayscalePalette();

        // State
        let center = [-0.5, 0.0];
        let zoom = 0.75; // Will be calculated based on aspect ratio
        let maxIterations = 128;
        let userHasInteracted = false; // Track if user has panned or zoomed manually

        // Calculate initial zoom to ensure complete Mandelbrot set is visible
        function calculateInitialZoom() {
            const aspectRatio = canvas.width / canvas.height;
            // Mandelbrot set bounds: x ∈ [-2.5, 1.0], y ∈ [-1.25, 1.25]
            // With center at [-0.5, 0.0], we need:
            // - x range: [-2.5, 1.0] requires ±2.0 around -0.5
            // - y range: [-1.25, 1.25] requires ±1.25 around 0
            return Math.min(aspectRatio / 2.0, 0.8);
        }
        
        // Initialize Web Workers
        function initWorkers() {
            if (computeWorker) {
                computeWorker.terminate();
            }
            if (renderWorker) {
                renderWorker.terminate();
            }
            
            computeWorker = new Worker('mandel-compute.js');
            renderWorker = new Worker('mandel-render.js');
            
            computeWorker.onmessage = onComputeComplete;
            renderWorker.onmessage = onRenderComplete;
            
            computeWorker.onerror = (e) => {
                console.error('Compute worker error:', e);
            };
            renderWorker.onerror = (e) => {
                console.error('Render worker error:', e);
            };
        }
        
        // Handle compute worker completion
        function onComputeComplete(e) {
            if (e.data.finished) {
                const mandel = new Uint8Array(e.data.mandel);
                let smoothMandel = null;
                if (e.data.smooth && e.data.smoothMandel) {
                    smoothMandel = new Uint8Array(e.data.smoothMandel);
                }
                
                // Prepare pixel buffer for rendering (RGBA format)
                const pixelBuffer = new Uint8Array(canvas.width * canvas.height * 4);
                
                // Start rendering - note the transferable objects syntax from the workers
                renderWorker.postMessage({
                    colours: grayscalePalette,
                    mandel: mandel.buffer,
                    canvasBuffer: pixelBuffer.buffer,
                    workerID: 0,
                    blockSize: 1,
                    arrayWidth: canvas.width,
                    smooth: e.data.smooth,
                    smoothMandel: smoothMandel ? smoothMandel.buffer : new ArrayBuffer(1)
                }, [mandel.buffer, pixelBuffer.buffer].concat(smoothMandel ? [smoothMandel.buffer] : []));
            }
        }
        
        // Handle render worker completion
        function onRenderComplete(e) {
            const pixelData = new Uint8ClampedArray(e.data.pixelsBuffer);
            
            // Copy pixel data to ImageData
            for (let i = 0; i < pixelData.length && i < imageData.data.length; i++) {
                imageData.data[i] = pixelData[i];
            }
            
            ctx.putImageData(imageData, 0, 0);
            isRendering = false;
            
            // Update UI
            const zoomText = zoom > 1000 ? zoom.toExponential(2) : zoom.toFixed(1) + '×';
            document.getElementById('zoom').textContent = zoomText;
            document.getElementById('iterations').textContent = maxIterations;
        }

        // Gesture state
        let isDragging = false;
        let lastTouch = null;
        let touches = [];
        let lastTap = 0;
        let initialDistance = 0;
        let initialZoom = 1;

        function resize() {
            const dpr = window.devicePixelRatio;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            
            // Create new image data for the new canvas size
            imageData = ctx.createImageData(canvas.width, canvas.height);
        }

        function render() {
            if (isRendering) return;
            isRendering = true;
            
            // Adaptive iterations based on zoom level
            const baseIterations = zoom > 1000 ? 256 : 128;
            maxIterations = Math.min(1024, Math.max(baseIterations, 
                Math.floor(baseIterations + Math.log10(Math.max(1, zoom)) * 32)));
            
            // Allocate data arrays
            mandelData = new Uint8Array(canvas.width * canvas.height);
            smoothMandelData = new Uint8Array(canvas.width * canvas.height);
            
            // Calculate zoom factor and screen position for coordinate transformation
            // The Web Worker expects screenX/screenY to be the pixel coordinates of the center point
            const zoomFactor = zoom * Math.min(canvas.width, canvas.height) / 4;
            const screenX = canvas.width / 2 - center[0] * zoomFactor;
            const screenY = canvas.height / 2 + center[1] * zoomFactor;
            
            // Start computation
            computeWorker.postMessage({
                mandelBuffer: mandelData.buffer,
                smoothMandel: smoothMandelData.buffer,
                workerID: 0,
                startLine: 0,
                blockSize: 1,
                canvasWidth: canvas.width,
                segmentHeight: canvas.height,
                screenX: screenX,
                screenY: screenY,
                zoom: zoomFactor,
                iterations: maxIterations,
                smooth: 1,
                oneShot: 0
            }, [mandelData.buffer, smoothMandelData.buffer]);
        }

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (touches.length === 1) {
                isDragging = true;
                lastTouch = { x: touches[0].clientX, y: touches[0].clientY };
                
                // Double tap
                const now = Date.now();
                if (now - lastTap < 300) {
                    userHasInteracted = true;
                    const x = (touches[0].clientX / window.innerWidth) * 2 - 1;
                    const y = -((touches[0].clientY / window.innerHeight) * 2 - 1);
                    center[0] += x * (canvas.width / canvas.height) / zoom;
                    center[1] += y / zoom;
                    zoom *= 2;
                    render();
                }
                lastTap = now;
            } else if (touches.length === 2) {
                isDragging = false;
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                initialDistance = Math.sqrt(dx * dx + dy * dy);
                initialZoom = zoom;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (isDragging && touches.length === 1 && lastTouch) {
                userHasInteracted = true;
                const dx = touches[0].clientX - lastTouch.x;
                const dy = touches[0].clientY - lastTouch.y;
                center[0] -= dx / window.innerWidth * 2 / zoom * (canvas.width / canvas.height);
                center[1] += dy / window.innerHeight * 2 / zoom;
                lastTouch = { x: touches[0].clientX, y: touches[0].clientY };
                render();
            } else if (touches.length === 2 && initialDistance > 0) {
                userHasInteracted = true;
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const scale = distance / initialDistance;
                zoom = Math.max(0.1, Math.min(1e10, initialZoom * scale));
                render();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDragging = false;
            lastTouch = null;
            if (e.touches.length === 0) {
                initialDistance = 0;
            }
        });

        // Mouse events
        let mouseDown = false;
        let mouseStart = null;

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseStart = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown && mouseStart) {
                userHasInteracted = true;
                const dx = e.clientX - mouseStart.x;
                const dy = e.clientY - mouseStart.y;
                center[0] -= dx / window.innerWidth * 2 / zoom * (canvas.width / canvas.height);
                center[1] += dy / window.innerHeight * 2 / zoom;
                mouseStart = { x: e.clientX, y: e.clientY };
                render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
            mouseStart = null;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            userHasInteracted = true;
            const scale = e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(0.1, Math.min(1e10, zoom * scale));
            render();
        });

        // Reset button
        document.getElementById('resetBtn').addEventListener('click', () => {
            center = [-0.5, 0.0];
            zoom = calculateInitialZoom();
            userHasInteracted = false;
            render();
        });

        // Initialize
        window.addEventListener('resize', () => {
            resize();
            // Only recalculate zoom for orientation changes if user hasn't manually interacted
            if (!userHasInteracted && center[0] === -0.5 && center[1] === 0.0) {
                zoom = calculateInitialZoom();
            }
            render();
        });
        
        // Initialize everything
        initWorkers();
        resize();
        zoom = calculateInitialZoom(); // Set initial zoom based on aspect ratio
        render();

        // Service Worker for PWA
        if ('serviceWorker' in navigator) {
            const sw = `
                self.addEventListener('install', e => self.skipWaiting());
                self.addEventListener('activate', e => e.waitUntil(clients.claim()));
                self.addEventListener('fetch', e => e.respondWith(fetch(e.request)));
            `;
            const blob = new Blob([sw], { type: 'application/javascript' });
            navigator.serviceWorker.register(URL.createObjectURL(blob));
        }

        // Auto-hide info
        let infoTimeout;
        function showInfo() {
            document.getElementById('info').classList.remove('hidden');
            clearTimeout(infoTimeout);
            infoTimeout = setTimeout(() => {
                document.getElementById('info').classList.add('hidden');
            }, 3000);
        }

        canvas.addEventListener('touchstart', showInfo);
        canvas.addEventListener('mousedown', showInfo);
        showInfo();
    </script>
</body>
</html>