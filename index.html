<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Mandelbrot Explorer</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #000;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 11px;
            font-weight: 300;
            letter-spacing: 0.5px;
            pointer-events: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 4px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: opacity 0.3s ease;
        }

        .info.hidden {
            opacity: 0;
        }

        .reset-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .reset-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.2);
        }

        .gesture-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.4);
            font-size: 14px;
            text-align: center;
            pointer-events: none;
            animation: fadeOut 3s ease-out forwards;
            animation-delay: 1s;
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="info" id="info">
        <div>ZOOM: <span id="zoom">1.0×</span></div>
        <div>ITER: <span id="iterations">128</span></div>
    </div>
    
    <div class="gesture-hint">
        Pinch to zoom • Drag to pan • Double tap to zoom
    </div>

    <div class="reset-btn" id="resetBtn">↺</div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', {
            antialias: false,
            preserveDrawingBuffer: false,
            powerPreference: 'high-performance'
        });

        if (!gl) {
            alert('WebGL2 not supported');
        }

        // Vertex shader
        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_coord;
            uniform vec2 u_center;
            uniform float u_zoom;
            uniform float u_aspectRatio;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                vec2 coord = a_position;
                coord.x *= u_aspectRatio;
                v_coord = coord / u_zoom + u_center;
            }
        `;

        // Fragment shader - grayscale palette
        const fragmentShaderSource = `#version 300 es
            precision highp float;
            in vec2 v_coord;
            out vec4 fragColor;
            uniform int u_maxIterations;
            
            vec3 palette(float t) {
                // Linear grayscale inverted: 0 = white, 1 = black
                t = clamp(t, 0.0, 1.0);
                return vec3(1.0 - t);
            }
            
            void main() {
                vec2 c = v_coord;
                vec2 z = vec2(0.0);
                int iter = 0;
                
                for(int i = 0; i < 1024; i++) {
                    if(i >= u_maxIterations) break;
                    
                    float x = z.x * z.x - z.y * z.y + c.x;
                    float y = 2.0 * z.x * z.y + c.y;
                    z = vec2(x, y);
                    
                    if(dot(z, z) > 4.0) {
                        iter = i;
                        break;
                    }
                }
                
                if(iter == 0 || iter == u_maxIterations) {
                    // Inside the set - black
                    fragColor = vec4(0.0, 0.0, 0.0, 1.0);
                } else {
                    // Outside the set - gradient to white
                    float smooth_iter = float(iter) - log2(log2(dot(z, z))) + 4.0;
                    vec3 color = palette(float(iter) / float(u_maxIterations));
                    fragColor = vec4(color, 1.0);
                }
            }
        `;

        // Compile shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        // Create program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        // Get uniform locations
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const centerLocation = gl.getUniformLocation(program, 'u_center');
        const zoomLocation = gl.getUniformLocation(program, 'u_zoom');
        const aspectRatioLocation = gl.getUniformLocation(program, 'u_aspectRatio');
        const maxIterationsLocation = gl.getUniformLocation(program, 'u_maxIterations');

        // Create vertex buffer
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);

        // Create VAO
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.enableVertexAttribArray(positionLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // State
        let center = [-0.5, 0.0];
        let zoom = 0.75; // Increased to 0.75 for closer initial view
        let maxIterations = 128;

        // Gesture state
        let isDragging = false;
        let lastTouch = null;
        let touches = [];
        let lastTap = 0;
        let initialDistance = 0;
        let initialZoom = 1;

        function resize() {
            const dpr = window.devicePixelRatio;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function render() {
            gl.useProgram(program);
            gl.bindVertexArray(vao);
            
            gl.uniform2f(centerLocation, center[0], center[1]);
            gl.uniform1f(zoomLocation, zoom);
            gl.uniform1f(aspectRatioLocation, canvas.width / canvas.height);
            gl.uniform1i(maxIterationsLocation, maxIterations);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            document.getElementById('zoom').textContent = 
                zoom > 1000 ? zoom.toExponential(1) : zoom.toFixed(1) + '×';
            document.getElementById('iterations').textContent = maxIterations;
        }

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (touches.length === 1) {
                isDragging = true;
                lastTouch = { x: touches[0].clientX, y: touches[0].clientY };
                
                // Double tap
                const now = Date.now();
                if (now - lastTap < 300) {
                    const x = (touches[0].clientX / window.innerWidth) * 2 - 1;
                    const y = -((touches[0].clientY / window.innerHeight) * 2 - 1);
                    center[0] += x * (canvas.width / canvas.height) / zoom;
                    center[1] += y / zoom;
                    zoom *= 2;
                    maxIterations = Math.min(1024, Math.floor(maxIterations * 1.2));
                    render();
                }
                lastTap = now;
            } else if (touches.length === 2) {
                isDragging = false;
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                initialDistance = Math.sqrt(dx * dx + dy * dy);
                initialZoom = zoom;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (isDragging && touches.length === 1 && lastTouch) {
                const dx = touches[0].clientX - lastTouch.x;
                const dy = touches[0].clientY - lastTouch.y;
                center[0] -= dx / window.innerWidth * 2 / zoom * (canvas.width / canvas.height);
                center[1] += dy / window.innerHeight * 2 / zoom;
                lastTouch = { x: touches[0].clientX, y: touches[0].clientY };
                render();
            } else if (touches.length === 2 && initialDistance > 0) {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const scale = distance / initialDistance;
                zoom = Math.max(0.1, Math.min(1e10, initialZoom * scale));
                maxIterations = Math.min(1024, Math.floor(128 + Math.log10(zoom) * 50));
                render();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDragging = false;
            lastTouch = null;
            if (e.touches.length === 0) {
                initialDistance = 0;
            }
        });

        // Mouse events
        let mouseDown = false;
        let mouseStart = null;

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseStart = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown && mouseStart) {
                const dx = e.clientX - mouseStart.x;
                const dy = e.clientY - mouseStart.y;
                center[0] -= dx / window.innerWidth * 2 / zoom * (canvas.width / canvas.height);
                center[1] += dy / window.innerHeight * 2 / zoom;
                mouseStart = { x: e.clientX, y: e.clientY };
                render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
            mouseStart = null;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scale = e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(0.1, Math.min(1e10, zoom * scale));
            maxIterations = Math.min(1024, Math.floor(128 + Math.log10(zoom) * 50));
            render();
        });

        // Reset button
        document.getElementById('resetBtn').addEventListener('click', () => {
            center = [-0.5, 0.0];
            zoom = 0.75;
            maxIterations = 128;
            render();
        });

        // Initialize
        window.addEventListener('resize', () => {
            resize();
            render();
        });
        
        resize();
        render();

        // Service Worker for PWA
        if ('serviceWorker' in navigator) {
            const sw = `
                self.addEventListener('install', e => self.skipWaiting());
                self.addEventListener('activate', e => e.waitUntil(clients.claim()));
                self.addEventListener('fetch', e => e.respondWith(fetch(e.request)));
            `;
            const blob = new Blob([sw], { type: 'application/javascript' });
            navigator.serviceWorker.register(URL.createObjectURL(blob));
        }

        // Auto-hide info
        let infoTimeout;
        function showInfo() {
            document.getElementById('info').classList.remove('hidden');
            clearTimeout(infoTimeout);
            infoTimeout = setTimeout(() => {
                document.getElementById('info').classList.add('hidden');
            }, 3000);
        }

        canvas.addEventListener('touchstart', showInfo);
        canvas.addEventListener('mousedown', showInfo);
        showInfo();
    </script>
</body>
</html>