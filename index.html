<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Mandelbrot Explorer</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #000;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 11px;
            font-weight: 300;
            letter-spacing: 0.5px;
            pointer-events: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 4px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: opacity 0.3s ease;
        }

        .info.hidden {
            opacity: 0;
        }

        .reset-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .reset-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.2);
        }

        .gesture-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.4);
            font-size: 14px;
            text-align: center;
            pointer-events: none;
            animation: fadeOut 3s ease-out forwards;
            animation-delay: 1s;
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="info" id="info">
        <div>ZOOM: <span id="zoom">1.0×</span></div>
        <div>ITER: <span id="iterations">128</span></div>
        <div id="precision-hint" style="font-size: 10px; color: rgba(255,255,255,0.6); margin-top: 4px;"></div>
    </div>
    
    <div class="gesture-hint">
        Pinch to zoom • Drag to pan • Double tap to zoom
    </div>

    <div class="reset-btn" id="resetBtn">↺</div>

    <canvas id="canvas"></canvas>

    <script>
        // Simple arbitrary precision number implementation for Mandelbrot calculations
        class ArbitraryPrecision {
            constructor(value, precision = 50) {
                this.precision = precision;
                if (typeof value === 'string') {
                    this.value = parseFloat(value);
                } else {
                    this.value = value;
                }
            }
            
            static set(config) {
                ArbitraryPrecision.defaultPrecision = config.precision || 50;
            }
            
            add(other) {
                return new ArbitraryPrecision(this.value + (other.value || other), this.precision);
            }
            
            sub(other) {
                return new ArbitraryPrecision(this.value - (other.value || other), this.precision);
            }
            
            mul(other) {
                return new ArbitraryPrecision(this.value * (other.value || other), this.precision);
            }
            
            plus(other) { return this.add(other); }
            minus(other) { return this.sub(other); }
            
            pow(exp) {
                return new ArbitraryPrecision(Math.pow(this.value, exp), this.precision);
            }
            
            gt(other) {
                return this.value > (other.value || other);
            }
            
            lt(other) {
                return this.value < (other.value || other);
            }
            
            toNumber() {
                return this.value;
            }
            
            toString() {
                return this.value.toString();
            }
        }
        
        // Use our simple implementation as fallback
        const Decimal = ArbitraryPrecision;

        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', {
            antialias: false,
            preserveDrawingBuffer: false,
            powerPreference: 'high-performance'
        });

        if (!gl) {
            alert('WebGL2 not supported');
        }

        // Vertex shader
        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_coord;
            uniform vec2 u_center;
            uniform float u_zoom;
            uniform float u_aspectRatio;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                vec2 coord = a_position;
                coord.x *= u_aspectRatio;
                v_coord = coord / u_zoom + u_center;
            }
        `;

        // Check for double precision support
        const hasDoublePrecision = gl.getExtension('GL_ARB_gpu_shader_fp64') || 
                                  gl.getExtension('GL_EXT_gpu_shader_fp64');
        
        console.log('Double precision support:', hasDoublePrecision ? 'YES' : 'NO');

        // Configure Decimal.js for arbitrary precision
        Decimal.set({ precision: 50, rounding: 4 }); // Start with 50 decimal places

        // Arbitrary precision Mandelbrot computation using CPU
        function mandelbrotArbitraryPrecision(cx, cy, maxIter, precision = 50) {
            // Set precision based on zoom level
            Decimal.set({ precision: precision });
            
            const c_x = new Decimal(cx);
            const c_y = new Decimal(cy);
            let z_x = new Decimal(0);
            let z_y = new Decimal(0);
            
            // Early bailout for points obviously outside the set
            const c_dot = c_x.mul(c_x).plus(c_y.mul(c_y));
            if (c_dot.gt(4)) {
                return { iter: 1, escapeRadius: c_dot.toNumber() };
            }
            
            // Quick check for main cardioid and period-2 bulb
            const q = c_x.minus(0.25).pow(2).plus(c_y.pow(2));
            if (q.mul(q.plus(c_x.minus(0.25))).lt(new Decimal(0.25).mul(c_y.pow(2)))) {
                return { iter: 0, escapeRadius: 0 }; // Main cardioid
            }
            if (c_x.plus(1).pow(2).plus(c_y.pow(2)).lt(0.0625)) {
                return { iter: 0, escapeRadius: 0 }; // Period-2 bulb
            }
            
            for (let i = 0; i < maxIter; i++) {
                const zx2 = z_x.mul(z_x);
                const zy2 = z_y.mul(z_y);
                const radiusSquared = zx2.plus(zy2);
                
                if (radiusSquared.gt(4)) {
                    return { iter: i, escapeRadius: radiusSquared.toNumber() };
                }
                
                // z = z^2 + c
                const zxy = z_x.mul(z_y);
                z_x = zx2.minus(zy2).plus(c_x);
                z_y = zxy.mul(2).plus(c_y);
            }
            
            return { iter: maxIter, escapeRadius: z_x.mul(z_x).plus(z_y.mul(z_y)).toNumber() };
        }

        // Enhanced perturbation method for extreme zoom levels
        function mandelbrotPerturbation(cx, cy, refX, refY, deltaX, deltaY, maxIter, precision = 50) {
            // Improved perturbation theory implementation
            Decimal.set({ precision: precision });
            
            const ref_x = new Decimal(refX);
            const ref_y = new Decimal(refY);
            const delta_x = new Decimal(deltaX);
            const delta_y = new Decimal(deltaY);
            const c_x = ref_x.plus(delta_x);
            const c_y = ref_y.plus(delta_y);
            
            // Use reference orbit for better precision at extreme zoom levels
            // For simplicity, this uses the standard algorithm with higher precision
            // A full perturbation implementation would compute a reference orbit first
            return mandelbrotArbitraryPrecision(c_x.toString(), c_y.toString(), maxIter, precision);
        }

        // Cache for reference orbits (simplified version)
        let referenceOrbitCache = new Map();

        // Enhanced precision management with interpolation
        function getPrecisionForZoom(zoom) {
            if (zoom < 1000) return { mode: 'gpu', precision: 32 };
            if (zoom < 1e6) return { mode: 'gpu-double', precision: 64 };
            if (zoom < 1e12) return { mode: 'cpu', precision: Math.min(75, 50 + Math.floor(Math.log10(zoom / 1e6) * 5)) };
            if (zoom < 1e20) return { mode: 'cpu', precision: Math.min(125, 100 + Math.floor(Math.log10(zoom / 1e12) * 5)) };
            return { mode: 'cpu-perturbation', precision: Math.min(200, 150 + Math.floor(Math.log10(zoom / 1e20) * 10)) };
        }

        // Fragment shader - advanced version with double precision support and grayscale palette
        const fragmentShaderSource = `#version 300 es
            ${hasDoublePrecision ? '#extension GL_ARB_gpu_shader_fp64 : enable' : ''}
            precision highp float;
            ${hasDoublePrecision ? 'precision highp double;' : ''}
            
            in vec2 v_coord;
            out vec4 fragColor;
            uniform int u_maxIterations;
            uniform float u_zoom;
            
            vec3 palette(float t) {
                // Enhanced grayscale palette with smooth gradients
                t = clamp(t, 0.0, 1.0);
                // Smooth curve for better visual contrast
                t = smoothstep(0.0, 1.0, t);
                return vec3(1.0 - t);
            }
            
            ${hasDoublePrecision ? `
            // Double precision version for high zoom levels
            void mandelbrotDouble(dvec2 c, out int iter, out double escapeRadius) {
                dvec2 z = dvec2(0.0);
                iter = 0;
                escapeRadius = 0.0;
                
                // Early bailout for points obviously outside the set
                double c_dot = dot(c, c);
                if(c_dot > 4.0) {
                    iter = 1;
                    escapeRadius = c_dot;
                    return;
                }
                
                for(int i = 0; i < 1024; i++) {
                    if(i >= u_maxIterations) break;
                    
                    double zx2 = z.x * z.x;
                    double zy2 = z.y * z.y;
                    
                    // Optimized: check escape condition before expensive calculations
                    double radiusSquared = zx2 + zy2;
                    if(radiusSquared > 4.0) {
                        iter = i;
                        escapeRadius = radiusSquared;
                        break;
                    }
                    
                    // z = z^2 + c (optimized to avoid duplicate calculations)
                    double zxy = z.x * z.y;
                    z.x = zx2 - zy2 + c.x;
                    z.y = 2.0 * zxy + c.y;
                }
                
                if(iter == u_maxIterations) {
                    escapeRadius = dot(z, z);
                }
            }
            ` : ''}
            
            // Single precision fallback version
            void mandelbrotFloat(vec2 c, out int iter, out float escapeRadius) {
                vec2 z = vec2(0.0);
                iter = 0;
                escapeRadius = 0.0;
                
                // Early bailout for points obviously outside the set
                float c_dot = dot(c, c);
                if(c_dot > 4.0) {
                    iter = 1;
                    escapeRadius = c_dot;
                    return;
                }
                
                // Quick check for main cardioid and period-2 bulb
                float q = pow(c.x - 0.25, 2.0) + c.y * c.y;
                if(q * (q + (c.x - 0.25)) < 0.25 * c.y * c.y) return; // Main cardioid
                if((c.x + 1.0) * (c.x + 1.0) + c.y * c.y < 0.0625) return; // Period-2 bulb
                
                for(int i = 0; i < 1024; i++) {
                    if(i >= u_maxIterations) break;
                    
                    float zx2 = z.x * z.x;
                    float zy2 = z.y * z.y;
                    
                    // Optimized: check escape condition before expensive calculations
                    float radiusSquared = zx2 + zy2;
                    if(radiusSquared > 4.0) {
                        iter = i;
                        escapeRadius = radiusSquared;
                        break;
                    }
                    
                    // z = z^2 + c (optimized to avoid duplicate calculations)
                    float zxy = z.x * z.y;
                    z.x = zx2 - zy2 + c.x;
                    z.y = 2.0 * zxy + c.y;
                }
                
                if(iter == u_maxIterations) {
                    escapeRadius = dot(z, z);
                }
            }
            
            void main() {
                int iter;
                float escapeRadius;
                
                ${hasDoublePrecision ? `
                // Use double precision for high zoom levels (> 1000x)
                if(u_zoom > 1000.0) {
                    dvec2 c = dvec2(v_coord);
                    double escapeRadiusDouble;
                    mandelbrotDouble(c, iter, escapeRadiusDouble);
                    escapeRadius = float(escapeRadiusDouble);
                } else {
                    mandelbrotFloat(v_coord, iter, escapeRadius);
                }
                ` : `
                // Fallback to single precision
                mandelbrotFloat(v_coord, iter, escapeRadius);
                `}
                
                if(iter == 0 || iter == u_maxIterations) {
                    // Inside the set - black
                    fragColor = vec4(0.0, 0.0, 0.0, 1.0);
                } else {
                    // Outside the set - smooth grayscale gradient
                    float smooth_iter = float(iter);
                    if(escapeRadius > 4.0) {
                        smooth_iter = float(iter) - log2(log2(escapeRadius)) + 4.0;
                    }
                    
                    vec3 color = palette(smooth_iter / float(u_maxIterations));
                    fragColor = vec4(color, 1.0);
                }
            }
        `;

        // Compile shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        // Create program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        // Get uniform locations
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const centerLocation = gl.getUniformLocation(program, 'u_center');
        const zoomLocation = gl.getUniformLocation(program, 'u_zoom');
        const aspectRatioLocation = gl.getUniformLocation(program, 'u_aspectRatio');
        const maxIterationsLocation = gl.getUniformLocation(program, 'u_maxIterations');

        // Create vertex buffer
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);

        // Create VAO
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.enableVertexAttribArray(positionLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // State
        let center = [-0.5, 0.0];
        let zoom = 0.75; // Increased to 0.75 for closer initial view
        let maxIterations = 128;
        let currentPrecisionMode = 'gpu';

        // CPU rendering canvas for arbitrary precision
        let cpuCanvas = null;
        let cpuCtx = null;
        let cpuImageData = null;

        // Gesture state
        let isDragging = false;
        let lastTouch = null;
        let touches = [];
        let lastTap = 0;
        let initialDistance = 0;
        let initialZoom = 1;

        function resize() {
            const dpr = window.devicePixelRatio;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            // Setup CPU canvas for arbitrary precision rendering
            if (!cpuCanvas) {
                cpuCanvas = document.createElement('canvas');
                cpuCtx = cpuCanvas.getContext('2d');
            }
            // Use lower resolution for CPU rendering to maintain performance
            const cpuRes = Math.min(512, Math.max(256, Math.min(canvas.width, canvas.height) / 4));
            cpuCanvas.width = cpuRes;
            cpuCanvas.height = cpuRes;
            cpuImageData = cpuCtx.createImageData(cpuCanvas.width, cpuCanvas.height);
        }

        // CPU-based rendering for arbitrary precision with optimizations
        async function renderCPU() {
            const precisionInfo = getPrecisionForZoom(zoom);
            const width = cpuCanvas.width;
            const height = cpuCanvas.height;
            const aspectRatio = canvas.width / canvas.height;
            
            console.log(`Rendering with ${precisionInfo.mode} precision (${precisionInfo.precision} digits)`);
            
            const data = cpuImageData.data;
            
            // Calculate adaptive iterations
            const baseIterations = 256;
            const adaptiveIterations = Math.min(1024, Math.max(baseIterations, 
                Math.floor(baseIterations + Math.log10(Math.max(1, zoom)) * 32)));
            
            // Batch processing for better performance
            const batchSize = 16; // Process rows in batches
            
            for (let batch = 0; batch < height; batch += batchSize) {
                const endBatch = Math.min(batch + batchSize, height);
                
                // Process batch
                for (let py = batch; py < endBatch; py++) {
                    for (let px = 0; px < width; px++) {
                        // Convert pixel to complex plane coordinates
                        const x = ((px / width) * 2 - 1) * aspectRatio / zoom + center[0];
                        const y = ((py / height) * 2 - 1) / zoom + center[1];
                        
                        let result;
                        if (precisionInfo.mode === 'cpu-perturbation' && zoom > 1e20) {
                            // Use perturbation for extreme zoom levels
                            result = mandelbrotPerturbation(x, y, center[0], center[1], 
                                x - center[0], y - center[1], adaptiveIterations, precisionInfo.precision);
                        } else {
                            // Use regular arbitrary precision
                            result = mandelbrotArbitraryPrecision(x, y, adaptiveIterations, precisionInfo.precision);
                        }
                        
                        const pixelIndex = (py * width + px) * 4;
                        
                        if (result.iter === 0 || result.iter === adaptiveIterations) {
                            // Inside the set - black
                            data[pixelIndex] = 0;     // R
                            data[pixelIndex + 1] = 0; // G
                            data[pixelIndex + 2] = 0; // B
                        } else {
                            // Outside the set - smooth grayscale gradient
                            let smooth_iter = result.iter;
                            if (result.escapeRadius > 4) {
                                smooth_iter = result.iter - Math.log2(Math.log2(result.escapeRadius)) + 4;
                            }
                            
                            // Enhanced grayscale palette with better contrast
                            let t = smooth_iter / adaptiveIterations;
                            t = Math.max(0, Math.min(1, t));
                            // Apply multiple smoothing functions for better visual appeal
                            t = t * t * (3 - 2 * t); // smoothstep
                            t = Math.sqrt(t); // Additional curve adjustment
                            const intensity = Math.floor((1 - t) * 255);
                            
                            data[pixelIndex] = intensity;     // R
                            data[pixelIndex + 1] = intensity; // G
                            data[pixelIndex + 2] = intensity; // B
                        }
                        data[pixelIndex + 3] = 255; // A
                    }
                }
                
                // Update progress after each batch and allow UI updates
                const progress = (endBatch / height * 100).toFixed(1);
                document.getElementById('iterations').textContent = `${adaptiveIterations} (${progress}%)`;
                
                // Allow UI to update between batches
                if (batch + batchSize < height) {
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
            
            // Draw the computed image to CPU canvas
            cpuCtx.putImageData(cpuImageData, 0, 0);
            
            // Draw CPU canvas to main WebGL canvas
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // Create a texture from the CPU canvas
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, cpuCanvas);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            
            // Simple shader to display the texture
            const textureProgram = createTextureProgram();
            gl.useProgram(textureProgram.program);
            gl.bindVertexArray(vao);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(textureProgram.textureLocation, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            gl.deleteTexture(texture);
            
            // Final progress update
            document.getElementById('iterations').textContent = adaptiveIterations;
        }

        // Create simple texture rendering program
        function createTextureProgram() {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, `#version 300 es
                in vec2 a_position;
                out vec2 v_texCoord;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                    v_texCoord = a_position * 0.5 + 0.5;
                    v_texCoord.y = 1.0 - v_texCoord.y;
                }
            `);
            
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, `#version 300 es
                precision highp float;
                in vec2 v_texCoord;
                out vec4 fragColor;
                uniform sampler2D u_texture;
                void main() {
                    fragColor = texture(u_texture, v_texCoord);
                }
            `);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            return {
                program: program,
                textureLocation: gl.getUniformLocation(program, 'u_texture')
            };
        }

        async function render() {
            const precisionInfo = getPrecisionForZoom(zoom);
            currentPrecisionMode = precisionInfo.mode;
            
            // Use CPU rendering for extreme zoom levels
            if (precisionInfo.mode === 'cpu' || precisionInfo.mode === 'cpu-perturbation') {
                await renderCPU();
            } else {
                // Use GPU rendering for normal zoom levels
                renderGPU();
            }
            
            // Update UI with current state
            const zoomText = zoom > 1000 ? zoom.toExponential(2) : zoom.toFixed(1) + '×';
            let precisionText, hintText;
            switch (precisionInfo.mode) {
                case 'gpu': 
                    precisionText = ' (float)';
                    hintText = '32-bit GPU precision';
                    break;
                case 'gpu-double': 
                    precisionText = hasDoublePrecision ? ' (double)' : ' (float)';
                    hintText = hasDoublePrecision ? '64-bit GPU precision' : '32-bit GPU fallback';
                    break;
                case 'cpu': 
                    precisionText = ` (arb-${precisionInfo.precision})`;
                    hintText = `${precisionInfo.precision}-digit CPU precision`;
                    break;
                case 'cpu-perturbation': 
                    precisionText = ` (pert-${precisionInfo.precision})`;
                    hintText = `${precisionInfo.precision}-digit perturbation method`;
                    break;
            }
            document.getElementById('zoom').textContent = zoomText + precisionText;
            document.getElementById('precision-hint').textContent = hintText;
            if (!precisionInfo.mode.startsWith('cpu')) {
                document.getElementById('iterations').textContent = maxIterations;
            }
        }

        function renderGPU() {
            gl.useProgram(program);
            gl.bindVertexArray(vao);
            
            // Pass uniforms to both vertex and fragment shaders
            gl.uniform2f(centerLocation, center[0], center[1]);
            gl.uniform1f(zoomLocation, zoom);
            gl.uniform1f(aspectRatioLocation, canvas.width / canvas.height);
            
            // Optimized iteration count based on zoom level and double precision support
            const baseIterations = hasDoublePrecision && zoom > 1000 ? 256 : 128;
            const adaptiveIterations = Math.min(1024, Math.max(baseIterations, 
                Math.floor(baseIterations + Math.log10(Math.max(1, zoom)) * 32)));
            maxIterations = adaptiveIterations;
            
            gl.uniform1i(maxIterationsLocation, maxIterations);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (touches.length === 1) {
                isDragging = true;
                lastTouch = { x: touches[0].clientX, y: touches[0].clientY };
                
                // Double tap
                const now = Date.now();
                if (now - lastTap < 300) {
                    const x = (touches[0].clientX / window.innerWidth) * 2 - 1;
                    const y = -((touches[0].clientY / window.innerHeight) * 2 - 1);
                    center[0] += x * (canvas.width / canvas.height) / zoom;
                    center[1] += y / zoom;
                    zoom *= 2;
                    render();
                }
                lastTap = now;
            } else if (touches.length === 2) {
                isDragging = false;
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                initialDistance = Math.sqrt(dx * dx + dy * dy);
                initialZoom = zoom;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (isDragging && touches.length === 1 && lastTouch) {
                const dx = touches[0].clientX - lastTouch.x;
                const dy = touches[0].clientY - lastTouch.y;
                center[0] -= dx / window.innerWidth * 2 / zoom * (canvas.width / canvas.height);
                center[1] += dy / window.innerHeight * 2 / zoom;
                lastTouch = { x: touches[0].clientX, y: touches[0].clientY };
                render();
            } else if (touches.length === 2 && initialDistance > 0) {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const scale = distance / initialDistance;
                zoom = Math.max(0.1, Math.min(1e10, initialZoom * scale));
                render();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDragging = false;
            lastTouch = null;
            if (e.touches.length === 0) {
                initialDistance = 0;
            }
        });

        // Mouse events
        let mouseDown = false;
        let mouseStart = null;

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseStart = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown && mouseStart) {
                const dx = e.clientX - mouseStart.x;
                const dy = e.clientY - mouseStart.y;
                center[0] -= dx / window.innerWidth * 2 / zoom * (canvas.width / canvas.height);
                center[1] += dy / window.innerHeight * 2 / zoom;
                mouseStart = { x: e.clientX, y: e.clientY };
                render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
            mouseStart = null;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scale = e.deltaY > 0 ? 0.9 : 1.1;
            const oldZoom = zoom;
            zoom = Math.max(0.1, Math.min(1e30, zoom * scale)); // Increased max zoom
            
            // If transitioning between precision modes, provide feedback
            const oldMode = getPrecisionForZoom(oldZoom).mode;
            const newMode = getPrecisionForZoom(zoom).mode;
            if (oldMode !== newMode) {
                console.log(`Precision mode changed: ${oldMode} → ${newMode}`);
                showInfo();
            }
            
            render();
        });

        // Reset button
        document.getElementById('resetBtn').addEventListener('click', () => {
            center = [-0.5, 0.0];
            zoom = 0.75;
            render();
        });

        // Keyboard shortcuts for precision testing
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case '+':
                case '=':
                    zoom *= 10;
                    zoom = Math.min(1e30, zoom);
                    render();
                    e.preventDefault();
                    break;
                case '-':
                    zoom /= 10;
                    zoom = Math.max(0.1, zoom);
                    render();
                    e.preventDefault();
                    break;
                case 'r':
                case 'R':
                    center = [-0.5, 0.0];
                    zoom = 0.75;
                    render();
                    e.preventDefault();
                    break;
                case 'h':
                case 'H':
                    alert('Keyboard shortcuts:\n+ = Zoom in 10x\n- = Zoom out 10x\nr = Reset view\nh = Show this help');
                    e.preventDefault();
                    break;
            }
        });

        // Initialize
        window.addEventListener('resize', () => {
            resize();
            render();
        });
        
        resize();
        render();

        // Service Worker for PWA
        if ('serviceWorker' in navigator) {
            const sw = `
                self.addEventListener('install', e => self.skipWaiting());
                self.addEventListener('activate', e => e.waitUntil(clients.claim()));
                self.addEventListener('fetch', e => e.respondWith(fetch(e.request)));
            `;
            const blob = new Blob([sw], { type: 'application/javascript' });
            navigator.serviceWorker.register(URL.createObjectURL(blob));
        }

        // Auto-hide info
        let infoTimeout;
        function showInfo() {
            document.getElementById('info').classList.remove('hidden');
            clearTimeout(infoTimeout);
            infoTimeout = setTimeout(() => {
                document.getElementById('info').classList.add('hidden');
            }, 3000);
        }

        canvas.addEventListener('touchstart', showInfo);
        canvas.addEventListener('mousedown', showInfo);
        showInfo();
    </script>
</body>
</html>