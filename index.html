<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Mandelbrot Explorer</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #000;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 11px;
            font-weight: 300;
            letter-spacing: 0.5px;
            pointer-events: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 4px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: opacity 0.3s ease;
        }

        .info.hidden {
            opacity: 0;
        }

        .reset-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .reset-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.2);
        }

        .gesture-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.4);
            font-size: 14px;
            text-align: center;
            pointer-events: none;
            animation: fadeOut 3s ease-out forwards;
            animation-delay: 1s;
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="info" id="info">
        <div>ZOOM: <span id="zoom">1.0×</span></div>
        <div>ITER: <span id="iterations">128</span></div>
    </div>
    
    <div class="gesture-hint">
        Pinch to zoom • Drag to pan • Double tap to zoom
    </div>

    <div class="reset-btn" id="resetBtn">↺</div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', {
            antialias: false,
            preserveDrawingBuffer: false,
            powerPreference: 'high-performance'
        });

        if (!gl) {
            alert('WebGL2 not supported');
        }

        // Vertex shader
        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_coord;
            uniform vec2 u_center;
            uniform float u_zoom;
            uniform float u_aspectRatio;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                vec2 coord = a_position;
                coord.x *= u_aspectRatio;
                v_coord = coord / u_zoom + u_center;
            }
        `;

        // Check for double precision support
        const hasDoublePrecision = gl.getExtension('GL_ARB_gpu_shader_fp64') || 
                                  gl.getExtension('GL_EXT_gpu_shader_fp64');
        
        console.log('Double precision support:', hasDoublePrecision ? 'YES' : 'NO');

        // Fragment shader - advanced version with double precision support and grayscale palette
        const fragmentShaderSource = `#version 300 es
            ${hasDoublePrecision ? '#extension GL_ARB_gpu_shader_fp64 : enable' : ''}
            precision highp float;
            ${hasDoublePrecision ? 'precision highp double;' : ''}
            
            in vec2 v_coord;
            out vec4 fragColor;
            uniform int u_maxIterations;
            uniform float u_zoom;
            
            vec3 palette(float t) {
                // Enhanced grayscale palette with smooth gradients
                t = clamp(t, 0.0, 1.0);
                // Smooth curve for better visual contrast
                t = smoothstep(0.0, 1.0, t);
                return vec3(1.0 - t);
            }
            
            ${hasDoublePrecision ? `
            // Double precision version for high zoom levels
            void mandelbrotDouble(dvec2 c, out int iter, out double escapeRadius) {
                dvec2 z = dvec2(0.0);
                iter = 0;
                escapeRadius = 0.0;
                
                // Early bailout for points obviously outside the set
                double c_dot = dot(c, c);
                if(c_dot > 4.0) {
                    iter = 1;
                    escapeRadius = c_dot;
                    return;
                }
                
                for(int i = 0; i < 1024; i++) {
                    if(i >= u_maxIterations) break;
                    
                    double zx2 = z.x * z.x;
                    double zy2 = z.y * z.y;
                    
                    // Optimized: check escape condition before expensive calculations
                    double radiusSquared = zx2 + zy2;
                    if(radiusSquared > 4.0) {
                        iter = i;
                        escapeRadius = radiusSquared;
                        break;
                    }
                    
                    // z = z^2 + c (optimized to avoid duplicate calculations)
                    double zxy = z.x * z.y;
                    z.x = zx2 - zy2 + c.x;
                    z.y = 2.0 * zxy + c.y;
                }
                
                if(iter == u_maxIterations) {
                    escapeRadius = dot(z, z);
                }
            }
            ` : ''}
            
            // Single precision fallback version
            void mandelbrotFloat(vec2 c, out int iter, out float escapeRadius) {
                vec2 z = vec2(0.0);
                iter = 0;
                escapeRadius = 0.0;
                
                // Early bailout for points obviously outside the set
                float c_dot = dot(c, c);
                if(c_dot > 4.0) {
                    iter = 1;
                    escapeRadius = c_dot;
                    return;
                }
                
                // Quick check for main cardioid and period-2 bulb
                float q = pow(c.x - 0.25, 2.0) + c.y * c.y;
                if(q * (q + (c.x - 0.25)) < 0.25 * c.y * c.y) return; // Main cardioid
                if((c.x + 1.0) * (c.x + 1.0) + c.y * c.y < 0.0625) return; // Period-2 bulb
                
                for(int i = 0; i < 1024; i++) {
                    if(i >= u_maxIterations) break;
                    
                    float zx2 = z.x * z.x;
                    float zy2 = z.y * z.y;
                    
                    // Optimized: check escape condition before expensive calculations
                    float radiusSquared = zx2 + zy2;
                    if(radiusSquared > 4.0) {
                        iter = i;
                        escapeRadius = radiusSquared;
                        break;
                    }
                    
                    // z = z^2 + c (optimized to avoid duplicate calculations)
                    float zxy = z.x * z.y;
                    z.x = zx2 - zy2 + c.x;
                    z.y = 2.0 * zxy + c.y;
                }
                
                if(iter == u_maxIterations) {
                    escapeRadius = dot(z, z);
                }
            }
            
            void main() {
                int iter;
                float escapeRadius;
                
                ${hasDoublePrecision ? `
                // Use double precision for high zoom levels (> 1000x)
                if(u_zoom > 1000.0) {
                    dvec2 c = dvec2(v_coord);
                    double escapeRadiusDouble;
                    mandelbrotDouble(c, iter, escapeRadiusDouble);
                    escapeRadius = float(escapeRadiusDouble);
                } else {
                    mandelbrotFloat(v_coord, iter, escapeRadius);
                }
                ` : `
                // Fallback to single precision
                mandelbrotFloat(v_coord, iter, escapeRadius);
                `}
                
                if(iter == 0 || iter == u_maxIterations) {
                    // Inside the set - black
                    fragColor = vec4(0.0, 0.0, 0.0, 1.0);
                } else {
                    // Outside the set - smooth grayscale gradient
                    float smooth_iter = float(iter);
                    if(escapeRadius > 4.0) {
                        smooth_iter = float(iter) - log2(log2(escapeRadius)) + 4.0;
                    }
                    
                    vec3 color = palette(smooth_iter / float(u_maxIterations));
                    fragColor = vec4(color, 1.0);
                }
            }
        `;

        // Compile shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        // Create program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        // Get uniform locations
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const centerLocation = gl.getUniformLocation(program, 'u_center');
        const zoomLocation = gl.getUniformLocation(program, 'u_zoom');
        const aspectRatioLocation = gl.getUniformLocation(program, 'u_aspectRatio');
        const maxIterationsLocation = gl.getUniformLocation(program, 'u_maxIterations');

        // Create vertex buffer
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);

        // Create VAO
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.enableVertexAttribArray(positionLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // State
        let center = [-0.5, 0.0];
        let zoom = 0.75; // Will be calculated based on aspect ratio
        let maxIterations = 128;
        let userHasInteracted = false; // Track if user has panned or zoomed manually

        // Calculate initial zoom to ensure complete Mandelbrot set is visible
        function calculateInitialZoom() {
            const aspectRatio = canvas.width / canvas.height;
            // Mandelbrot set bounds: x ∈ [-2.5, 1.0], y ∈ [-1.25, 1.25]
            // With center at [-0.5, 0.0], we need:
            // - x range: [-2.5, 1.0] requires ±2.0 around -0.5
            // - y range: [-1.25, 1.25] requires ±1.25 around 0
            // From shader: x_range = ±aspectRatio/zoom, y_range = ±1/zoom
            return Math.min(aspectRatio / 2.0, 0.8);
        }

        // Gesture state
        let isDragging = false;
        let lastTouch = null;
        let touches = [];
        let lastTap = 0;
        let initialDistance = 0;
        let initialZoom = 1;

        function resize() {
            const dpr = window.devicePixelRatio;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function render() {
            gl.useProgram(program);
            gl.bindVertexArray(vao);
            
            // Pass uniforms to both vertex and fragment shaders
            gl.uniform2f(centerLocation, center[0], center[1]);
            gl.uniform1f(zoomLocation, zoom);
            gl.uniform1f(aspectRatioLocation, canvas.width / canvas.height);
            
            // Optimized iteration count based on zoom level and double precision support
            const baseIterations = hasDoublePrecision && zoom > 1000 ? 256 : 128;
            const adaptiveIterations = Math.min(1024, Math.max(baseIterations, 
                Math.floor(baseIterations + Math.log10(Math.max(1, zoom)) * 32)));
            maxIterations = adaptiveIterations;
            
            gl.uniform1i(maxIterationsLocation, maxIterations);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // Update UI with current state
            const zoomText = zoom > 1000 ? zoom.toExponential(2) : zoom.toFixed(1) + '×';
            const precisionText = hasDoublePrecision && zoom > 1000 ? ' (double)' : ' (float)';
            document.getElementById('zoom').textContent = zoomText + precisionText;
            document.getElementById('iterations').textContent = maxIterations;
        }

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (touches.length === 1) {
                isDragging = true;
                lastTouch = { x: touches[0].clientX, y: touches[0].clientY };
                
                // Double tap
                const now = Date.now();
                if (now - lastTap < 300) {
                    userHasInteracted = true;
                    const x = (touches[0].clientX / window.innerWidth) * 2 - 1;
                    const y = -((touches[0].clientY / window.innerHeight) * 2 - 1);
                    center[0] += x * (canvas.width / canvas.height) / zoom;
                    center[1] += y / zoom;
                    zoom *= 2;
                    render();
                }
                lastTap = now;
            } else if (touches.length === 2) {
                isDragging = false;
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                initialDistance = Math.sqrt(dx * dx + dy * dy);
                initialZoom = zoom;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            touches = Array.from(e.touches);
            
            if (isDragging && touches.length === 1 && lastTouch) {
                userHasInteracted = true;
                const dx = touches[0].clientX - lastTouch.x;
                const dy = touches[0].clientY - lastTouch.y;
                center[0] -= dx / window.innerWidth * 2 / zoom * (canvas.width / canvas.height);
                center[1] += dy / window.innerHeight * 2 / zoom;
                lastTouch = { x: touches[0].clientX, y: touches[0].clientY };
                render();
            } else if (touches.length === 2 && initialDistance > 0) {
                userHasInteracted = true;
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const scale = distance / initialDistance;
                zoom = Math.max(0.1, Math.min(1e10, initialZoom * scale));
                render();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDragging = false;
            lastTouch = null;
            if (e.touches.length === 0) {
                initialDistance = 0;
            }
        });

        // Mouse events
        let mouseDown = false;
        let mouseStart = null;

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseStart = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown && mouseStart) {
                userHasInteracted = true;
                const dx = e.clientX - mouseStart.x;
                const dy = e.clientY - mouseStart.y;
                center[0] -= dx / window.innerWidth * 2 / zoom * (canvas.width / canvas.height);
                center[1] += dy / window.innerHeight * 2 / zoom;
                mouseStart = { x: e.clientX, y: e.clientY };
                render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
            mouseStart = null;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            userHasInteracted = true;
            const scale = e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(0.1, Math.min(1e10, zoom * scale));
            render();
        });

        // Reset button
        document.getElementById('resetBtn').addEventListener('click', () => {
            center = [-0.5, 0.0];
            zoom = calculateInitialZoom();
            userHasInteracted = false;
            render();
        });

        // Initialize
        window.addEventListener('resize', () => {
            resize();
            // Only recalculate zoom for orientation changes if user hasn't manually interacted
            if (!userHasInteracted && center[0] === -0.5 && center[1] === 0.0) {
                zoom = calculateInitialZoom();
            }
            render();
        });
        
        resize();
        zoom = calculateInitialZoom(); // Set initial zoom based on aspect ratio
        render();

        // Service Worker for PWA
        if ('serviceWorker' in navigator) {
            const sw = `
                self.addEventListener('install', e => self.skipWaiting());
                self.addEventListener('activate', e => e.waitUntil(clients.claim()));
                self.addEventListener('fetch', e => e.respondWith(fetch(e.request)));
            `;
            const blob = new Blob([sw], { type: 'application/javascript' });
            navigator.serviceWorker.register(URL.createObjectURL(blob));
        }

        // Auto-hide info
        let infoTimeout;
        function showInfo() {
            document.getElementById('info').classList.remove('hidden');
            clearTimeout(infoTimeout);
            infoTimeout = setTimeout(() => {
                document.getElementById('info').classList.add('hidden');
            }, 3000);
        }

        canvas.addEventListener('touchstart', showInfo);
        canvas.addEventListener('mousedown', showInfo);
        showInfo();
    </script>
</body>
</html>